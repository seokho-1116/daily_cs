### 1. 해시 테이블이란?

- 키-값(key-value) 저장 방식의 Abstract data type
    - 키-값 저장 방식
        - 키와 값이 매칭되도록 저장함
        - ex) 철수 - 183cm
- 빠른 조회 속도를 제공하는 효율적인 자료구조
    - 왜 빠른가?
        - 키와 값이 매칭되어 있음
        - 그러므로 키만 알고 있다면 평균적으로 O(1)의 시간으로 데이터에 접근할 수 있음
- 해시 함수(Hash Function)를 사용하여 데이터를 배열 인덱스에 매핑
    - 해시 함수란?
        - 특정 입력에 대해서 고정된 길이의 출력을 제공(가변이 될 수도)
    - 어떻게 키와 값에 대한 매칭을 제공할 수 있는가?
        - 키를 해시 함수에 넣어서 그 값으로 해시 테이블의 버킷 또는 인덱스를 구해서 값에 매칭
- 삽입과 삭제는
    - 삽입 - O(1)
        - 키로 버킷이나 인덱스 위치만 구하고 바로 넣으면 되니깐
        - 해시 충돌 상태라면?
    - 삭제 - O(1)
        - 키로 버킷이나 인덱스 위치만 구하고 바로 삭제하면 되니깐
        - 해시 충돌 상태라면?

### 2. 해시 테이블에서 해시 충돌(Hash Collision)과 해결 방법

- 충돌은 해시 함수에 영향을 받을 수도 있음
    - 충돌이 적은 **좋은 해시 함수**를 사용하면 성능이 향상
    - 충돌이 많으면 탐색 성능이 O(n)까지 나빠질 수 있음
- **개방 주소법 (Open Addressing)**
    - 개방 주소법은 해싱된 키를 통해 구한 버킷이나 인덱스가 있거나 없을 때까지 탐색하는 방식
    - 성능은 load factor에 영향을 받음. load factor가 100%에 가까울 수록 탐색이 많이 발생함
    - 해시 테이블이 load factor 임계치를 넘어서면 리해싱을 통해 성능이 개선됨.
        - Why? 새로운 버킷에 재배치되거나 충돌이 감소해 탐색 시간이 감소됨
    - 선형 탐사(Linear Probing)
        - 충돌이 발생하면 값을 넣을 수 있는 가장 가까운 위치를 탐색
        - 조회는 그 값의 위치에서부터 순차 탐색
        - 충돌이 많으면 불리할 수도? 하지만 참조 지역성은 좋음
    - 이차 탐사(Quadratic Probing)
        - 충돌이 발생하면 매핑된 버킷 또는 인덱스 값에 임의의 2차 다항식 값을 더하여 값을 넣을 수 있는 위치 탐색
        - 선형 탐사의 대안으로 사용되지만 특정 상황에서는 참조 지역성이 떨어져 선형 탐사보다 느림
    - 이중 해싱(Double Hashing)
        - 충돌 발생 시 서로 다른 해시 함수 2개를 사용하여 두 번 해싱
        - 충돌 횟수에 따른 탐색 위치 조절
        - 두 번째 해시 함수를 기반으로 위치가 선정되기에 선형 탐사나 이차 탐사보다는 충돌 중복이나 위치가 클러스터링되는 것이 최소화됨
- **체이닝(Chaining)**
    - 각 버킷(bucket)에 연결 리스트(Linked List) 또는 트리(Tree) 활용
    - 연결 리스트나 트리를 통해 충돌 시 탐색
        - 동적으로 크기 조절 가능
    - 노드가 많아지면 연결 리스트의 경우 O(n)가지 복잡도 증가
        - 자바에서는 레드 블랙 트리로 변환되어 O(log n)을 가져감
    - 삽입/삭제?
        - 연결 리스트나 트리에서 제거하면 됨
        - 연결 리스트의 경우 O(1), 레드 블랙 트리라고 가정하면 O(log n)

### 3. 해시 테이블의 시간 복잡도

- **평균적으로 O(1)**
    - 키-값의 형태로 저장되기에 키만 알면 값에 바로 접근 가능하기에 O(1)
- **최악의 경우 O(n)** (충돌이 많거나, 해시 함수 성능이 낮을 때)
    - 보통 해시 충돌이 발생한 경우
    - 체이닝을 썼을 때 O(log n)
        - 레드 블랙 트리 또는 링크드 리스트

### 4. 해시 테이블의 활용 사례

- **캐싱 (Caching):** LRU 캐시 구현
- **데이터베이스 인덱싱:** B-Tree, Hash Index
- **중복 검사:** 방문한 URL 저장, Bloom Filter
- **로그 분석:** 빠른 로그 검색

### 5. Java에서 Hash Table 구현

- **`HashMap` (동기화 미지원) vs `Hashtable` (동기화 지원)**
- **ConcurrentHashMap** (멀티스레드 환경)

**💡 연습 문제:**

1. 배열을 이용하여 직접 해시 테이블을 구현해보세요.
2. `HashMap`을 사용하여 LRU(Least Recently Used) 캐시를 만들어보세요.
3. 해시 충돌을 해결하는 개방 주소법과 체이닝 방식을 각각 구현해 비교해보세요.

# 참고자료

https://en.wikipedia.org/wiki/Hash_table

https://en.wikipedia.org/wiki/Double_hashing

https://en.wikipedia.org/wiki/Open_addressing

https://en.wikipedia.org/wiki/Linear_probing

https://en.wikipedia.org/wiki/Quadratic_probing

https://d2.naver.com/helloworld/831311
